parcel_proposals <- gs_url(sheet_url) %>% gs_read("Sheet1", range = "A1:E60")
parcel_proposals$APN <- as.character(parcel_proposals$APN)
row.names(parcel_proposals) <- parcel_proposals$APN
weights_url <- "https://docs.google.com/spreadsheets/d/18_XTChwbtd8dMn_7WDp_qXF6d_VXAhRexgjQTgJq0NY/"
weights <- gs_url(weights_url) %>% gs_read("Sheet1", range = "A1:R18")
row.names(weights) <- weights$type
parcel_proposals <- parcel_proposals %>% subset(select = -name)
parcel_proposals <- parcel_proposals %>% gather(num, type, -APN) %>% subset(select = -num)
parcel_proposals <- parcel_proposals[complete.cases(parcel_proposals$type),]
new_parcel_types <- unique(parcel_proposals$type)
new_parcel_types <- new_parcel_types[new_parcel_types != 'vacant']
type_counts <- unlist(lapply(new_parcel_types, function(p_type) return( nrow(parcel_proposals[parcel_proposals$type == p_type,]))))
names(type_counts) <- new_parcel_types
temp_merged <- merged_data_parcels %>% full_join(parcel_proposals, by = c( "parcel" = "APN"))
temp_merged$rank <- NA
temp_merged <- weight_adder(temp_merged, weights)
temp_merged <- subset(temp_merged, select = -parcel) # >
temp_merged <- rbind(merged_data[,names(temp_merged)], temp_merged) # >
temp_merged <- temp_merged[order(temp_merged$spatial_id, temp_merged$type, temp_merged$crow_distance), ] # >
temp_merged <- temp_merged %>% filter(spatial_id %in% biking$spatial_id) # >
temp_merged <- temp_merged[complete.cases(temp_merged$crow_distance),] # >
row.names(temp_merged) <- 1:nrow(temp_merged)
temp_merged <- temp_merged[temp_merged$type != 'vacant', ]
temp_merged <- bind_rows(lapply(split.data.frame(temp_merged, f = temp_merged$spatial_id), type_splitter))
temp_merged <- temp_merged[complete.cases(temp_merged$rank),]
temp_merged$scores <- score_calc(temp_merged$time_biking, temp_merged$time_driving, temp_merged$time_transit, temp_merged$time_walking, temp_merged$abs_good, temp_merged$rank, temp_merged$type)
new_scores <- temp_merged %>% group_by(spatial_id) %>% summarise('new_score' = sum(scores, na.rm = TRUE))
runApp()
returned_objects()[[2]]
View(data.shape@data)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map.R', echo=TRUE)
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
base_map
runApp()
runApp()
runApp()
runApp()
runApp()
load("dashboard_map_data.RData")
View(data.shape@data)
data.shape@data$access_score <- new_scores$new_score
View(data.shape@data)
save(bg_scores, merged_data, merged_data_parcels, biking, file = "dashboard_data.RData")
runApp()
new_scores <- scenario()
data.shape@data <- left_join(data.shape@data, new_scores, by = "spatial_id")
View(data.shape@data)
class(sspz_boundary)
View(sspz_boundary@data)
sspz_bgs <- read.csv('sspzbgpop.csv')
View(sspz_bgs)
?mapply
View(new_scores)
sspz_bgs$spatial_id <- mapply(paste, "0",sspz_bgs)
sspz_bgs$spatial_id <- mapply(paste, "0", sspz_bgs$bg)
sspz_bgs$spatial_id <- mapply(paste, "0", sspz_bgs$bg, sep = "")
save.image()
?filter
View(bg_scores)
filter(bg_scores, spatial_id %in% sspz_bgs$spatial_id)
filter(bg_scores, spatial_id %in% sspz_bgs$spatial_id)$baseline_score
filter(bg_scores, spatial_id %in% sspz_bgs$spatial_id)$baseline_score
sum(filter(bg_scores, spatial_id %in% sspz_bgs$spatial_id)$baseline_score)
runApp()
runApp()
runApp()
runApp()
View(data.shape@data)
load("dashboard_map_data.RData")
View(data.shape@data)
new_scores <- scenario()
data.shape@data <- left_join(data.shape@data, new_scores, by = "spatial_id")
data.shape@data$score_ratio <- (data.shape@data$new_score/data.shape@data$access_score)
runApp()
data.shape@data <- left_join(data.shape@data, new_scores, by = "spatial_id")
data.shape@data$score_ratio <- (data.shape@data$new_score/data.shape@data$access_score)
View(data.shape@data)
load("dashboard_map_data.RData")
View(data.shape@data)
runApp()
runApp()
runApp()
runApp()
class(base_map)
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map.R', echo=TRUE)
temp_objects <- make_map()
library(shiny)
library(sp)
library(leaflet)
library(googlesheets)
library(tidyr)
library(dplyr)
source("rank_fixer.R")
source("score_calc.R")
source("type_splitter.R")
source("weight_adder.R")
source("scenario.R")
source("marg_good_func.R")
source("make_map.R")
temp_objects <- make_map()
class(temp_objects[[1]])
class(temp_objects[[2]])
View(temp_objects[[2]])
pal <- colorNumeric(
palette = "RdYlGn",
domain = data.shape@data$new_score)
base_map <- leaflet(data.shape) %>%
addTiles() %>%
addPolygons(stroke = TRUE,opacity = 1,fillOpacity = 0.9, smoothFactor = 0.5,
color=~pal(new_score),weight = 1) %>%
addLegend("bottomright", pal = pal, values = ~new_score,
title = "New Scores",
labFormat = labelFormat(prefix = ""),
opacity = 1
)
View(data.shape@data)
class(temp_objects[[2]])
View
View(new_scores)
new_scores <- scenario()
data.shape@data <- left_join(data.shape@data, new_scores, by = "spatial_id")
data.shape@data$score_ratio <- (data.shape@data$new_score/data.shape@data$access_score)
View(data.shape@data)
pal <- colorNumeric(
palette = "RdYlGn",
domain = data.shape@data$new_score)
base_map <- leaflet(data.shape) %>%
addTiles() %>%
addPolygons(stroke = TRUE,opacity = 1,fillOpacity = 0.9, smoothFactor = 0.5,
color=~pal(new_score),weight = 1) %>%
addLegend("bottomright", pal = pal, values = ~new_score,
title = "New Scores",
labFormat = labelFormat(prefix = ""),
opacity = 1
)
View(data.shape@data)
View(bg_scores)
bg_scores$baseline_score <- new_scores$new_score
save(bg_scores, merged_data, merged_data_parcels, biking, file = "dashboard_data.RData")
View(data.shape@data)
data.shape@data$access_score <- new_scores$new_score
View(data.shape@data)
save(base_map, data.shape, and sspz_boundary, file = "dashboard_map_data.RData")
save(base_map, data.shape, sspz_boundary, file = "dashboard_map_data.RData")
load("dashboard_map_data.RData")
View(data.shape@data)
data.shape@data <- subset(data.shape@data, select = -c(new_score, score_ratio))
View(data.shape@data)
save(base_map, data.shape, sspz_boundary, file = "dashboard_map_data.RData")
runApp()
View(scenario)
View(scenario)
View(temp_merged)
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/scenario.R', echo=TRUE)
shiny::runApp()
runApp()
install.packages(c("foreign", "MASS", "mgcv", "rgdal", "scales", "stringi", "survival"))
install.packages(c("foreign", "MASS", "mgcv", "rgdal", "scales", "stringi", "survival"))
install.packages(c("foreign", "MASS", "mgcv", "rgdal", "scales", "stringi", "survival"))
install.packages(c("foreign", "MASS", "mgcv", "rgdal", "scales", "stringi", "survival"))
is.na(NA)
!is.na(NA)
!1
!2
!
5 != 2
load(".RData")
View(temp_merged)
View(merged_data_parcels)
View(merged_data)
# Creating required variables for use later on
list_options <- unique(merged_data$type)
list_options
# Creating required variables for use later on
list_options <- c("All",unique(merged_data$type))
list_options
shiny::runApp()
View(bg_scores)
View(make_map)
View(make_map)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
test_type <- "doctor"
?filter
View(temp_merged)
View(filter(temp_merged, type == test_type))
type
test_type != "All"
View(temp_merged)
runApp()
View(new_scores)
View(bg_scores)
View(data.shape@data)
names(data.shape@data)
View(make_map)
View(make_map)
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map_base.R', echo=TRUE)
runApp()
View(new_scores)
View(new_scores)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/scenario.R', echo=TRUE)
runApp()
nrow(filter(temp_merged, type == type))
nrow(filter(temp_merged, type == "doctor"))
?filter
View(temp_merged)
nrow(filter(temp_merged, temp_merged$type == type))
nrow(filter(temp_merged, temp_merged$type == 'doctor'))
runApp()
nrow(temp_merged[temp_merged$type == 'doctor',])
runApp()
load("dashboard_data.RData")
load("dashboard_map_data.RData")
base_map
library(shiny)
library(sp)
library(leaflet)
library(googlesheets)
library(tidyr)
library(dplyr)
source("rank_fixer.R")
source("score_calc.R")
source("type_splitter.R")
source("weight_adder.R")
source("scenario.R")
source("marg_good_func.R")
source("make_map.R")
source("make_map_base.R")
View(data.shape@data)
View(make_map_base)
View(make_map_base)
View(make_map)
View(new_scores)
View(ideal_data)
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map_base.R', echo=TRUE)
runApp()
View(scenario)
View(scenario)
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/scenario.R', echo=TRUE)
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map_base.R', echo=TRUE)
runApp()
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map_base.R', echo=TRUE)
runApp()
type
# Used for testing, this does allow data.shape to start with a clean slate each time. Don't really know why I have to do this.
load("dashboard_map_data.RData")
View(data.shape@data)
View(bg_scores)
View(scenario())
sum(scenario()$new_score)
View(weights)
# Load the weights
weights_url <- "https://docs.google.com/spreadsheets/d/18_XTChwbtd8dMn_7WDp_qXF6d_VXAhRexgjQTgJq0NY/"
weights <- gs_url(weights_url) %>% gs_read("Sheet1", range = "A1:R18")
row.names(weights) <- weights$type
View(weights)
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/scenario.R', echo=TRUE)
runApp()
runApp()
View(bg_scores)
load("dashboard_data.RData")
View(bg_scores)
View(bg_scores)
runApp()
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map_base.R', echo=TRUE)
runApp()
make_map_base(parcel_proposals = parcel_proposals_sq)[[1]]
runApp()
make_map_base(ideal_data = ideal_data, parcel_proposals = parcel_proposals_sq)[[1]]
runApp()
make_map_base(ideal_data = ideal_data, parcel_proposals = parcel_proposals_sq)[[1]]
rm(list = ls())
source("rank_fixer.R")
source("score_calc.R")
source("type_splitter.R")
source("weight_adder.R")
source("scenario.R")
source("marg_good_func.R")
source("make_map.R")
source("make_map_base.R")
load("dashboard_data.RData")
load("dashboard_map_data.RData")
load(".RData")
# Creating required variables for use later on
list_options <- c("All",unique(merged_data$type))
# Loading and saving the status quo proposals.
# Load proposals
sheet_url <- "https://docs.google.com/spreadsheets/d/1R7dxLoPc-AjvmsdbExF5i2XyfMtZHIG24ziTj-er8Rk/"
# parcel_proposals <- read_csv("./inputs/parcel_proposals.csv", col_types = cols(APN = col_character(), type = col_character()))
parcel_proposals_sq <- gs_url(sheet_url) %>% gs_read("Sheet1", range = "A1:E60")
parcel_proposals_sq$APN <- as.character(parcel_proposals_sq$APN)
row.names(parcel_proposals_sq) <- parcel_proposals_sq$APN
make_map_base(ideal_data = ideal_data, parcel_proposals = parcel_proposals_sq)[[1]]
make_map_base(ideal_data = ideal_data, use_new = TRUE,parcel_proposals = parcel_proposals_sq)[[1]]
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map_base.R', echo=TRUE)
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map_base.R', echo=TRUE)
make_map_base(ideal_data = ideal_data, parcel_proposals = parcel_proposals_sq)[[1]]
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map_base.R', echo=TRUE)
make_map_base(ideal_data = ideal_data, parcel_proposals = parcel_proposals_sq)[[1]]
scenario(type = type, parcel_proposals = parcel_proposals, use_new = use_new)
scenario(type = type, parcel_proposals = parcel_proposals, use_new = use_new)
?scenario
??scenario
scenario(type = type, parcel_proposals = parcel_proposals_sq, use_new = use_new)
runApp()
View(ideal_data)
View(data.shape@data)
View(ideal_data)
View(amenity_info)
sum(ideal_data$score)
runApp()
View(merged_data)
View(score_calc)
View(merged_data_parcels)
View(merged_data)
shiny::runApp()
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/scenario.R', echo=TRUE)
runApp()
knitr::opts_chunk$set(echo = TRUE)
setwd("C:\\Users\\Derek\\Documents\\GitHub\\planning_dashboard_v2_updated\\pre_processing_work")
rm(list = ls())
library(googlesheets)
library(dplyr)
sheet_url <- "https://docs.google.com/spreadsheets/d/1R7dxLoPc-AjvmsdbExF5i2XyfMtZHIG24ziTj-er8Rk/"
# parcel_proposals <- read_csv("./inputs/parcel_proposals.csv", col_types = cols(APN = col_character(), type = col_character()))
current_conditions <- gs_url(sheet_url) %>% gs_read("Sheet1", range = "A1:E60")
current_conditions$APN <- as.character(current_conditions$APN)
row.names(current_conditions) <- current_conditions$APN
View(current_conditions)
weights_url <- "https://docs.google.com/spreadsheets/d/18_XTChwbtd8dMn_7WDp_qXF6d_VXAhRexgjQTgJq0NY/"
weights <- gs_url(weights_url) %>% gs_read("Sheet1", range = "A1:R18")
row.names(weights) <- weights$type
View(current_conditions)
View(weights)
save(current_conditions, weights, file = "data_defaults.RData")
rm(list = ls())
setwd("C:\\Users\\Derek\\Documents\\GitHub\\planning_dashboard_v2_updated\\planning_dashboard_v2")
load("dashboard_data.RData")
load("dashboard_map_data.RData")
load("data_defaults.RData")
load(".RData")
runApp()
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map_base.R', echo=TRUE)
runApp()
source("rank_fixer.R")
source("score_calc.R")
source("type_splitter.R")
source("weight_adder.R")
source("scenario.R")
source("marg_good_func.R")
source("make_map.R")
source("make_map_base.R")
runApp()
runApp()
runApp()
runApp()
View(data.shape@data)
View(weight_adder)
# tk - adjust weight adder here to change the weights for merged_data as well
merged_data <- subset(merged_data, selecct = -abs_good)
View(merged_data)
# tk - adjust weight adder here to change the weights for merged_data as well
merged_data <- subset(merged_data, selecct = -abs_good)
getwd(0)
getwd()
# When I clear everything, it can't seem to find merged_data_parcels. This is a hacker fix.
# Seems to work just fine on shinyapps so I really don't know what's going on.
# May keep this here because I'll need merged_data to be refreshed each time after incorporating the select type feature.
load("dashboard_data.RData")
# When I clear everything, it can't seem to find merged_data_parcels. This is a hacker fix.
# Seems to work just fine on shinyapps so I really don't know what's going on.
# May keep this here because I'll need merged_data to be refreshed each time after incorporating the select type feature.
load("dashboard_data.RData")
# tk - adjust weight adder here to change the weights for merged_data as well
merged_data <- subset(merged_data, selecct = -abs_good)
View(merged_data)
# tk - adjust weight adder here to change the weights for merged_data as well
merged_data <- merged_data[,-abs_good]
# tk - adjust weight adder here to change the weights for merged_data as well
merged_data <- merged_data[,-c(abs_good)]
# tk - adjust weight adder here to change the weights for merged_data as well
merged_data <- subset(merged_data, selecct = -c(abs_good))
View(merged_data)
# When I clear everything, it can't seem to find merged_data_parcels. This is a hacker fix.
# Seems to work just fine on shinyapps so I really don't know what's going on.
# May keep this here because I'll need merged_data to be refreshed each time after incorporating the select type feature.
load("dashboard_data.RData")
View(merged_data)
# tk - adjust weight adder here to change the weights for merged_data as well
merged_data <- subset(merged_data, selecct = -c(abs_good))
merged_data <- merged_data[,-12]
# When I clear everything, it can't seem to find merged_data_parcels. This is a hacker fix.
# Seems to work just fine on shinyapps so I really don't know what's going on.
# May keep this here because I'll need merged_data to be refreshed each time after incorporating the select type feature.
load("dashboard_data.RData")
which(names(merged_data))
which(names(merged_data) == "abs_good")
# tk - adjust weight adder here to change the weights for merged_data as well
merged_data <- subset(merged_data, selecct = -c(abs_good))
merged_data <- weight_adder(merged_data, weights)
merged_data <- merged_data[,-which(names(merged_data) == "abs_good"]
View(merged_data)
merged_data <- merged_data[,-which(names(merged_data) == "abs_good")]
temp_merged <- weight_adder(temp_merged, weights)
View(weight_adder)
View(merged_data,left_join(weights[,c('type','abs_good')], by = "type"))
View(merged_data)
View(left_join(merged_data,weights[,c('type','abs_good')], by = "type"))
replace_na(left_join(merged_data,weights[,c('type','abs_good')], by = "type")$abs_good, weights['other', 'abs_good'][[1]])
merged_data <- weight_adder(merged_data, weights)
# When I clear everything, it can't seem to find merged_data_parcels. This is a hacker fix.
# Seems to work just fine on shinyapps so I really don't know what's going on.
# May keep this here because I'll need merged_data to be refreshed each time after incorporating the select type feature.
load("dashboard_data.RData")
# Could use this if the above function doesn't work.
merged_data <- merged_data[,-which(names(merged_data) == "abs_good")]
merged_data <- weight_adder(merged_data, weights)
temp_merged <- weight_adder(temp_merged, weights)
runApp()
runApp()
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/make_map_base.R', echo=TRUE)
source('~/GitHub/planning_dashboard_v2_updated/planning_dashboard_v2/scenario.R', echo=TRUE)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(scenario())
# Used for testing, this does allow data.shape to start with a clean slate each time. Don't really know why I have to do this.
load("dashboard_map_data.RData")
View(data.shape@data)
View(data.shape@data)
View(subset(data.shape@data, select = -access_score))
data.shape@data <- subset(data.shape@data, select = -access_score)
View(data.shape@data)
save(base_map, data.shape, sspz_boundary, file = "dashboard_map_data.RData")
# Used for testing, this does allow data.shape to start with a clean slate each time. Don't really know why I have to do this.
load("dashboard_map_data.RData")
View(data.shape@data)
runApp()
new_scores <- scenario(type, use_new = FALSE)
View(new_scores)
View(scenario())
View(scenario(use_new = FALSE))
type
new_scores <- scenario(type = "All", use_new = FALSE)
View(new_scores)
data.shape@data <- left_join(data.shape@data, new_scores, by = "spatial_id")
View(data.shape@data)
data.shape@data$bench_ratio <- data.shape$new_score/sum(ideal_data$score)
data.shape@data$score_ratio <- (data.shape@data$new_score/data.shape@data$access_score)
returned_objects <- list("map" = new_map, "data" = data.shape@data)
View(data.shape@data)
runApp()
runApp()
View(current_conditions)
View(make_map)
View(new_score)
View(new_scores)
# Used for testing, this does allow data.shape to start with a clean slate each time.
load("dashboard_map_data.RData")
data.shape@data <- left_join(data.shape@data, new_scores, by = "spatial_id")
View(data.shape@data)
names(data.shape@data)
names(data.shape@data)[5]
names(data.shape@data)[5] <- "raw_scores"
View(make_map_base)
# Used for testing, this does allow data.shape to start with a clean slate each time. Don't really know why I have to do this.
load("dashboard_map_data.RData")
new_scores <- scenario(type = "All", use_new = FALSE)
data.shape@data <- left_join(data.shape@data, new_scores, by = "spatial_id")
data.shape@data$bench_ratio <- data.shape$new_score/sum(ideal_data$score)
data.shape@data$bench_ratio <- data.shape$new_score/sum(ideal_data$score)
View(data.shape@data)
names(data.shape@data)[5] <- "raw_score"
View(data.shape@data)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
